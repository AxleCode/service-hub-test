// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: inventory.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countListInventory = `-- name: CountListInventory :one
SELECT 
    COUNT(*) AS count
FROM inventory
WHERE is_deleted = FALSE
    AND (CASE WHEN $1::bool THEN barang_id = $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN jumlah = $4 ELSE TRUE END)
    AND (CASE WHEN $5::bool THEN status = $6 ELSE TRUE END)
    AND is_deleted = FALSE
`

type CountListInventoryParams struct {
	SetBarangID bool   `json:"set_barang_id"`
	BarangID    string `json:"barang_id"`
	SetJumlah   bool   `json:"set_jumlah"`
	Jumlah      int32  `json:"jumlah"`
	SetStatus   bool   `json:"set_status"`
	Status      string `json:"status"`
}

func (q *Queries) CountListInventory(ctx context.Context, arg CountListInventoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countListInventory,
		arg.SetBarangID,
		arg.BarangID,
		arg.SetJumlah,
		arg.Jumlah,
		arg.SetStatus,
		arg.Status,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOneInventory = `-- name: GetOneInventory :one
SELECT 
    guid,
    barang_id,
    jumlah,
    keterangan,
    status,
    created_at,
    updated_at
FROM inventory
WHERE guid = $1
  AND is_deleted = FALSE
`

type GetOneInventoryRow struct {
	Guid       string         `json:"guid"`
	BarangID   string         `json:"barang_id"`
	Jumlah     int32          `json:"jumlah"`
	Keterangan sql.NullString `json:"keterangan"`
	Status     string         `json:"status"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

func (q *Queries) GetOneInventory(ctx context.Context, guid string) (GetOneInventoryRow, error) {
	row := q.db.QueryRowContext(ctx, getOneInventory, guid)
	var i GetOneInventoryRow
	err := row.Scan(
		&i.Guid,
		&i.BarangID,
		&i.Jumlah,
		&i.Keterangan,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertInventory = `-- name: InsertInventory :one
INSERT INTO inventory (
    guid,
    barang_id,
    jumlah,
    keterangan,
    status,
    is_deleted,
    created_at,
    updated_at
    )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    FALSE,
    (now() at time zone 'UTC')::TIMESTAMP,
    (now() at time zone 'UTC')::TIMESTAMP
)
RETURNING inventory.guid, inventory.barang_id, inventory.jumlah, inventory.keterangan, inventory.status, inventory.is_deleted, inventory.created_at, inventory.updated_at
`

type InsertInventoryParams struct {
	Guid       string         `json:"guid"`
	BarangID   string         `json:"barang_id"`
	Jumlah     int32          `json:"jumlah"`
	Keterangan sql.NullString `json:"keterangan"`
	Status     string         `json:"status"`
}

func (q *Queries) InsertInventory(ctx context.Context, arg InsertInventoryParams) (Inventory, error) {
	row := q.db.QueryRowContext(ctx, insertInventory,
		arg.Guid,
		arg.BarangID,
		arg.Jumlah,
		arg.Keterangan,
		arg.Status,
	)
	var i Inventory
	err := row.Scan(
		&i.Guid,
		&i.BarangID,
		&i.Jumlah,
		&i.Keterangan,
		&i.Status,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInventory = `-- name: ListInventory :many
SELECT 
    guid,
    barang_id,
    jumlah,
    keterangan,
    status,
    created_at,
    updated_at
FROM inventory
WHERE is_deleted = FALSE
    AND (CASE WHEN $1::bool THEN barang_id = $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN jumlah = $4 ELSE TRUE END)
    AND (CASE WHEN $5::bool THEN status = $6 ELSE TRUE END)
ORDER BY
    (CASE WHEN $7 = 'created_at ASC' THEN created_at END) ASC,
    (CASE WHEN $7 = 'created_at DESC' THEN created_at END) DESC,
    (CASE WHEN $7 = 'jumlah ASC' THEN jumlah END) ASC,
    (CASE WHEN $7 = 'jumlah DESC' THEN jumlah END) DESC,
    created_at DESC
LIMIT $9
OFFSET $8
`

type ListInventoryParams struct {
	SetBarangID bool        `json:"set_barang_id"`
	BarangID    string      `json:"barang_id"`
	SetJumlah   bool        `json:"set_jumlah"`
	Jumlah      int32       `json:"jumlah"`
	SetStatus   bool        `json:"set_status"`
	Status      string      `json:"status"`
	OrderParam  interface{} `json:"order_param"`
	OffsetPages int32       `json:"offset_pages"`
	LimitData   int32       `json:"limit_data"`
}

type ListInventoryRow struct {
	Guid       string         `json:"guid"`
	BarangID   string         `json:"barang_id"`
	Jumlah     int32          `json:"jumlah"`
	Keterangan sql.NullString `json:"keterangan"`
	Status     string         `json:"status"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

func (q *Queries) ListInventory(ctx context.Context, arg ListInventoryParams) ([]ListInventoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listInventory,
		arg.SetBarangID,
		arg.BarangID,
		arg.SetJumlah,
		arg.Jumlah,
		arg.SetStatus,
		arg.Status,
		arg.OrderParam,
		arg.OffsetPages,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryRow
	for rows.Next() {
		var i ListInventoryRow
		if err := rows.Scan(
			&i.Guid,
			&i.BarangID,
			&i.Jumlah,
			&i.Keterangan,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
