// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: barang.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countListBarang = `-- name: CountListBarang :one
SELECT COUNT(*) AS total_data
FROM barang
WHERE is_deleted = FALSE
    AND (CASE WHEN $1::bool THEN kategori = $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN harga <= $4 ELSE TRUE END)
    AND is_deleted = FALSE
`

type CountListBarangParams struct {
	SetKategori bool   `json:"set_kategori"`
	Kategori    string `json:"kategori"`
	SetHarga    bool   `json:"set_harga"`
	Harga       string `json:"harga"`
}

func (q *Queries) CountListBarang(ctx context.Context, arg CountListBarangParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countListBarang,
		arg.SetKategori,
		arg.Kategori,
		arg.SetHarga,
		arg.Harga,
	)
	var total_data int64
	err := row.Scan(&total_data)
	return total_data, err
}

const getOneBarang = `-- name: GetOneBarang :one
SELECT 
    guid,
    kode_barang,
    nama_barang,
    kategori,
    deskripsi,
    harga,
    created_at,
    updated_at
FROM barang
WHERE guid = $1
  AND is_deleted = FALSE
`

type GetOneBarangRow struct {
	Guid       string         `json:"guid"`
	KodeBarang string         `json:"kode_barang"`
	NamaBarang string         `json:"nama_barang"`
	Kategori   string         `json:"kategori"`
	Deskripsi  sql.NullString `json:"deskripsi"`
	Harga      string         `json:"harga"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

func (q *Queries) GetOneBarang(ctx context.Context, guid string) (GetOneBarangRow, error) {
	row := q.db.QueryRowContext(ctx, getOneBarang, guid)
	var i GetOneBarangRow
	err := row.Scan(
		&i.Guid,
		&i.KodeBarang,
		&i.NamaBarang,
		&i.Kategori,
		&i.Deskripsi,
		&i.Harga,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertBarang = `-- name: InsertBarang :one
INSERT INTO barang (
    guid,
    kode_barang,
    nama_barang,
    deskripsi,
    kategori,
    harga,
    is_deleted,
    created_at,
    updated_at
    )
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    FALSE,
    (now() at time zone 'UTC')::TIMESTAMP,
    (now() at time zone 'UTC')::TIMESTAMP
)
RETURNING barang.guid, barang.kode_barang, barang.nama_barang, barang.kategori, barang.deskripsi, barang.harga, barang.is_deleted, barang.created_at, barang.updated_at
`

type InsertBarangParams struct {
	Guid       string         `json:"guid"`
	KodeBarang string         `json:"kode_barang"`
	NamaBarang string         `json:"nama_barang"`
	Deskripsi  sql.NullString `json:"deskripsi"`
	Kategori   string         `json:"kategori"`
	Harga      string         `json:"harga"`
}

func (q *Queries) InsertBarang(ctx context.Context, arg InsertBarangParams) (Barang, error) {
	row := q.db.QueryRowContext(ctx, insertBarang,
		arg.Guid,
		arg.KodeBarang,
		arg.NamaBarang,
		arg.Deskripsi,
		arg.Kategori,
		arg.Harga,
	)
	var i Barang
	err := row.Scan(
		&i.Guid,
		&i.KodeBarang,
		&i.NamaBarang,
		&i.Kategori,
		&i.Deskripsi,
		&i.Harga,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBarang = `-- name: ListBarang :many
SELECT 
    guid,
    kode_barang,
    nama_barang,
    kategori,
    deskripsi,
    harga,
    created_at,
    updated_at
FROM barang
WHERE is_deleted = FALSE
    AND (CASE WHEN $1::bool THEN kategori = $2 ELSE TRUE END)
    AND (CASE WHEN $3::bool THEN harga <= $4 ELSE TRUE END)
ORDER BY
    (CASE WHEN $5 = 'created_at ASC' THEN created_at END) ASC,
    (CASE WHEN $5 = 'created_at DESC' THEN created_at END) DESC,
    (CASE WHEN $5 = 'harga ASC' THEN harga END) ASC,
    (CASE WHEN $5 = 'harga DESC' THEN harga END) DESC,
    created_at DESC
LIMIT $7
OFFSET $6
`

type ListBarangParams struct {
	SetKategori bool        `json:"set_kategori"`
	Kategori    string      `json:"kategori"`
	SetHarga    bool        `json:"set_harga"`
	Harga       string      `json:"harga"`
	OrderParam  interface{} `json:"order_param"`
	OffsetPages int32       `json:"offset_pages"`
	LimitData   int32       `json:"limit_data"`
}

type ListBarangRow struct {
	Guid       string         `json:"guid"`
	KodeBarang string         `json:"kode_barang"`
	NamaBarang string         `json:"nama_barang"`
	Kategori   string         `json:"kategori"`
	Deskripsi  sql.NullString `json:"deskripsi"`
	Harga      string         `json:"harga"`
	CreatedAt  time.Time      `json:"created_at"`
	UpdatedAt  time.Time      `json:"updated_at"`
}

func (q *Queries) ListBarang(ctx context.Context, arg ListBarangParams) ([]ListBarangRow, error) {
	rows, err := q.db.QueryContext(ctx, listBarang,
		arg.SetKategori,
		arg.Kategori,
		arg.SetHarga,
		arg.Harga,
		arg.OrderParam,
		arg.OffsetPages,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBarangRow
	for rows.Next() {
		var i ListBarangRow
		if err := rows.Scan(
			&i.Guid,
			&i.KodeBarang,
			&i.NamaBarang,
			&i.Kategori,
			&i.Deskripsi,
			&i.Harga,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBarang = `-- name: UpdateBarang :one
UPDATE barang
SET
    kode_barang = $1,
    nama_barang = $2,
    kategori = $3,
    deskripsi = $4,
    harga = $5,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE guid = $6
  AND is_deleted = FALSE
RETURNING barang.guid, barang.kode_barang, barang.nama_barang, barang.kategori, barang.deskripsi, barang.harga, barang.is_deleted, barang.created_at, barang.updated_at
`

type UpdateBarangParams struct {
	KodeBarang string         `json:"kode_barang"`
	NamaBarang string         `json:"nama_barang"`
	Kategori   string         `json:"kategori"`
	Deskripsi  sql.NullString `json:"deskripsi"`
	Harga      string         `json:"harga"`
	Guid       string         `json:"guid"`
}

func (q *Queries) UpdateBarang(ctx context.Context, arg UpdateBarangParams) (Barang, error) {
	row := q.db.QueryRowContext(ctx, updateBarang,
		arg.KodeBarang,
		arg.NamaBarang,
		arg.Kategori,
		arg.Deskripsi,
		arg.Harga,
		arg.Guid,
	)
	var i Barang
	err := row.Scan(
		&i.Guid,
		&i.KodeBarang,
		&i.NamaBarang,
		&i.Kategori,
		&i.Deskripsi,
		&i.Harga,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStatusBarang = `-- name: UpdateStatusBarang :one
UPDATE barang
SET
    is_deleted = TRUE,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP
WHERE guid = $1
  AND is_deleted = FALSE
RETURNING barang.guid, barang.kode_barang, barang.nama_barang, barang.kategori, barang.deskripsi, barang.harga, barang.is_deleted, barang.created_at, barang.updated_at
`

func (q *Queries) UpdateStatusBarang(ctx context.Context, guid string) (Barang, error) {
	row := q.db.QueryRowContext(ctx, updateStatusBarang, guid)
	var i Barang
	err := row.Scan(
		&i.Guid,
		&i.KodeBarang,
		&i.NamaBarang,
		&i.Kategori,
		&i.Deskripsi,
		&i.Harga,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
